{ 
  "demo/src/main/java/com/cube/demo/CubeController.java ": 
{"imports":["org.springframework.web.bind.annotation.GetMapping","org.springframework.web.bind.annotation.RequestParam","org.springframework.web.bind.annotation.RestController"],"classes":[{"name":"CubeController","annotations":["RestController"],"extendedClass":"","implementedInterfaces":[],"fields":[],"methods":[{"name":"solveCube","returnType":"String","annotations":["GetMapping"],"parameters":["String colorInput","int stages"],"body":"{\n    return null;\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/DemoApplication.java ": 
{"imports":["org.springframework.boot.SpringApplication","org.springframework.boot.autoconfigure.SpringBootApplication"],"classes":[{"name":"DemoApplication","annotations":["SpringBootApplication"],"extendedClass":"","implementedInterfaces":[],"fields":[],"methods":[{"name":"main","returnType":"void","annotations":[],"parameters":["String[] args"],"body":"{\n    SpringApplication.run(DemoApplication.class, args);\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Main.java ": 
{"imports":["com.cube.demo.rbxcb.rbxcb_3x3x3.Model.Cube","com.cube.demo.rbxcb.rbxcb_3x3x3.Solvers.OLL_Solver","com.cube.demo.rbxcb.rbxcb_3x3x3.Solvers.Solver","com.cube.demo.rbxcb.rbxcb_3x3x3.Solvers._2StageSolver","java.util.ArrayList","java.util.Scanner"],"classes":[{"name":"Main","annotations":[],"extendedClass":"","implementedInterfaces":[],"fields":[],"methods":[{"name":"main","returnType":"void","annotations":[],"parameters":["String[] args"],"body":"{\n    // ygywbrrgwrbwyooyyygrbgwwgbgoboorroowbybwyobggrywrgbowr\n    //        Cube c = new Cube(\"gbbbbbgbbywroooyoowoowwwwwrwyrrrryrryroyyywyoggggggbgb\");\n    //        Cube c = new Cube(\"ygywbrrgwrbwyooyyygrbgwwgbgoboorroowbybwyobggrywrgbowr\");\n    String shuffle;\n    Scanner sc = new Scanner(System.in);\n    while (true) {\n        shuffle = sc.nextLine();\n        Cube c = new Cube();\n        c = Cube.execute(c, shuffle);\n        Solver s = new _2StageSolver();\n        ArrayList<String> sol = s.solve(c);\n        System.out.println(sol + \"  \" + sol.size());\n    }\n    //        shuffle = \"U F2 U' F2 D2 B2 L2 U' B2 U' B2 U2 L R B D2 F2 L R'\";\n    //        Cube c = new Cube();\n    //        c = Cube.execute(c, shuffle);\n    //        System.out.println(c);\n    //        c = new Cube();\n    //        c = Cube.execute(c,\"UU\");\n    //        System.out.println(c);\n    //        Scanner sc = new Scanner(System.in);\n    //        String colorInput;\n    //\n    //        while (true) {\n    //            colorInput = sc.nextLine();\n    //            Cube c = new Cube();\n    //            c = Cube.execute(c, colorInput);\n    //            ArrayList<String> sol = Cube.solveCube(c, 2);\n    //            System.out.println(sol + \" - \" + sol.size());\n    //        }\n    //        System.out.println(Cube.solveCube_4Stage(c));\n    //        c = Cube.execute(c,\"BDDDFLLFFFFFFFFFRRRRRRRRRUUUUUUUUUBBBBBBRRR\");\n    //        String sol1=c.solveStage(0,Cube.stagedMoveRestrictions_2Stage,Cube.maskStages_2Stage[0]);\n    //        System.out.println(Cube.getAlgorithm(sol1));\n    //        c = Cube.execute(c,sol1);\n    //        String sol = c.solveStage(1,Cube.stagedMoveRestrictions_2Stage,Cube.maskStages_2Stage[1]);\n    //        System.out.println(Cube.getAlgorithm(sol));\n    //        c = Cube.execute(c,sol);\n    //        System.out.println(c);\n    //        System.out.println(Cube.solveCube_2Stage(c));\n    //        String sol = c.solveStage(0, Cube.stagedMoveRestrictions_3Stage, Cube.maskStages_3Stage[0]);\n    //        System.out.println(Cube.getAlgorithm(sol));\n    //        System.out.println(Cube.maskStage1_3Stage(c));\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/StageSolver.java ": 
{"imports":["com.cube.demo.rbxcb.rbxcb_3x3x3.Masks.StageMasker","com.cube.demo.rbxcb.rbxcb_3x3x3.Model.Cube","java.util.ArrayList","java.util.Queue","java.util.concurrent","java.util.concurrent.atomic.AtomicReference"],"classes":[{"name":"StageSolver","annotations":[],"extendedClass":"","implementedInterfaces":[],"fields":[],"methods":[{"name":"solve","returnType":"String","annotations":[],"parameters":["Cube c","String[] moveRestrictions","StageMasker sm"],"body":"{\n    Cube source = c.clone();\n    Cube destination = new Cube();\n    if (sm.mask(source).equals(sm.mask(destination)))\n        return \"\";\n    class Temp {\n\n        final Cube c;\n\n        final String s;\n\n        public Temp(Cube c, String s) {\n            this.c = c.clone();\n            this.s = new String(s);\n        }\n    }\n    Queue<Temp> forward = new LinkedBlockingQueue<>();\n    Queue<Temp> backward = new LinkedBlockingQueue<>();\n    ConcurrentHashMap<ArrayList<Integer>, String> forwardSolution = new ConcurrentHashMap<>();\n    ConcurrentHashMap<ArrayList<Integer>, String> backwardSolution = new ConcurrentHashMap<>();\n    forwardSolution.put(sm.mask(source), \"\");\n    backwardSolution.put(sm.mask(destination), \"\");\n    forward.add(new Temp(source, \"\"));\n    backward.add(new Temp(destination, \"\"));\n    // Shared variable to store the result\n    AtomicReference<String> result = new AtomicReference<>(null);\n    CountDownLatch latch = new CountDownLatch(1);\n    ExecutorService executor = Executors.newFixedThreadPool(2);\n    // Forward search task\n    Runnable forwardSearch = () -> {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                Temp f = forward.poll();\n                if (f == null)\n                    continue;\n                for (String move : moveRestrictions) {\n                    Cube temp = Cube.execute(f.c, move);\n                    ArrayList<Integer> maskedState = sm.mask(temp);\n                    if (backwardSolution.containsKey(maskedState)) {\n                        result.set(f.s + move + Cube.reverseAlgorithm(backwardSolution.get(maskedState)));\n                        // Signal that a solution was found\n                        latch.countDown();\n                        return;\n                    }\n                    if (!forwardSolution.containsKey(maskedState)) {\n                        forwardSolution.put(maskedState, f.s + move);\n                        forward.add(new Temp(temp, f.s + move));\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    };\n    // Backward search task\n    Runnable backwardSearch = () -> {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                Temp b = backward.poll();\n                if (b == null)\n                    continue;\n                for (String move : moveRestrictions) {\n                    Cube temp = Cube.execute(b.c, move);\n                    ArrayList<Integer> maskedState = sm.mask(temp);\n                    if (forwardSolution.containsKey(maskedState)) {\n                        result.set(forwardSolution.get(maskedState) + Cube.reverseAlgorithm(b.s + move));\n                        // Signal that a solution was found\n                        latch.countDown();\n                        return;\n                    }\n                    if (!backwardSolution.containsKey(maskedState)) {\n                        backwardSolution.put(maskedState, b.s + move);\n                        backward.add(new Temp(temp, b.s + move));\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    };\n    // Submit both tasks to the executor\n    executor.submit(forwardSearch);\n    executor.submit(backwardSearch);\n    try {\n        // Wait for one thread to find a solution\n        latch.await();\n        // Stop all threads once a solution is found\n        executor.shutdownNow();\n        // Return the found solution\n        return result.get();\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    } finally {\n        // Ensure the executor is properly shut down\n        executor.shutdown();\n    }\n    // In case no solution is found\n    return null;\n}\n[Local class: Temp]"}],"nestedClasses":[{"name":"Temp","annotations":[],"extendedClass":"","implementedInterfaces":[],"fields":[{"name":"c","type":"Cube","annotations":[]},{"name":"s","type":"String","annotations":[]}],"methods":[],"nestedClasses":[]}]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Masks/StageMasker.java ": 
{"imports":["com.cube.demo.rbxcb.rbxcb_3x3x3.Model.Cube","java.util.ArrayList"],"classes":[{"name":"StageMasker","annotations":[],"extendedClass":"","implementedInterfaces":[],"fields":[],"methods":[{"name":"mask","returnType":"ArrayList<Integer>","annotations":[],"parameters":["Cube c"],"body":""}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Masks/CFOP_Mask/OLL_Mask.java ": 
{"imports":["com.cube.demo.rbxcb.rbxcb_3x3x3.Masks.StageMasker","com.cube.demo.rbxcb.rbxcb_3x3x3.Model","java.util.ArrayList"],"classes":[{"name":"OLL_Mask","annotations":[],"extendedClass":"","implementedInterfaces":["StageMasker"],"fields":[],"methods":[{"name":"mask","returnType":"ArrayList<Integer>","annotations":[],"parameters":["Cube c"],"body":"{\n    ArrayList<Integer> edgeMask = new ArrayList<>();\n    ArrayList<Integer> cornerMask = new ArrayList<>();\n    ArrayList<Integer> mask = new ArrayList<>();\n    EdgePos edgePos = c.getEdge().getEdgePos();\n    EdgeOrientation edgeOrientation = c.getEdge().getEdgeOrientation();\n    CornerPos cornerPos = c.getCorner().getCornerPos();\n    CornerOrientation cornerOrientation = c.getCorner().getCornerOrientation();\n    // Edge Positions Masking :\n    for (int i = 4; i < 12; i++) edgeMask.add((int) edgePos.getVal()[i]);\n    // Edge Orientation Masking :\n    for (int i = 0; i < 12; i++) edgeMask.add((int) edgeOrientation.getVal()[i]);\n    // Corner Position Masking :\n    for (int i = 4; i < 8; i++) cornerMask.add((int) cornerPos.getVal()[i]);\n    // Corner Orientation Masking :\n    for (int i = 0; i < 8; i++) cornerMask.add((int) cornerOrientation.getVal()[i]);\n    mask.addAll(edgeMask);\n    mask.addAll(cornerMask);\n    return mask;\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Masks/_2StageMask/Stage1.java ": 
{"imports":["com.cube.demo.rbxcb.rbxcb_3x3x3.Model.Cube","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks.StageMasker","java.util.ArrayList"],"classes":[{"name":"Stage1","annotations":[],"extendedClass":"","implementedInterfaces":["StageMasker"],"fields":[],"methods":[{"name":"mask","returnType":"ArrayList<Integer>","annotations":[],"parameters":["Cube c"],"body":"{\n    StageMasker sm = new com.cube.demo.rbxcb.rbxcb_3x3x3.Masks._3StageMask.Stage1();\n    return sm.mask(c);\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Masks/_2StageMask/Stage2.java ": 
{"imports":["com.cube.demo.rbxcb.rbxcb_3x3x3.Model.Cube","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks._4StageMask.Stage4","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks.StageMasker","java.util.ArrayList"],"classes":[{"name":"Stage2","annotations":[],"extendedClass":"","implementedInterfaces":["StageMasker"],"fields":[],"methods":[{"name":"mask","returnType":"ArrayList<Integer>","annotations":[],"parameters":["Cube c"],"body":"{\n    StageMasker sm = new Stage4();\n    return sm.mask(c);\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Masks/_3StageMask/Stage1.java ": 
{"imports":["com.cube.demo.rbxcb.rbxcb_3x3x3.Masks.StageMasker","com.cube.demo.rbxcb.rbxcb_3x3x3.Model","java.util.ArrayList","java.util.Arrays"],"classes":[{"name":"Stage1","annotations":[],"extendedClass":"","implementedInterfaces":["StageMasker"],"fields":[],"methods":[{"name":"mask","returnType":"ArrayList<Integer>","annotations":[],"parameters":["Cube c"],"body":"{\n    ArrayList<ArrayList<Integer>> edgeMask = new ArrayList<>();\n    ArrayList<Integer> cornerMask = new ArrayList<>();\n    ArrayList<Integer> mask = new ArrayList<>();\n    EdgePos edgePos = c.getEdge().getEdgePos();\n    EdgeOrientation edgeOrientation = c.getEdge().getEdgeOrientation();\n    CornerPos cornerPos = c.getCorner().getCornerPos();\n    CornerOrientation cornerOrientation = c.getCorner().getCornerOrientation();\n    for (int i = 0; i < 12; i++) edgeMask.add(new ArrayList<>(Arrays.asList(0, 0)));\n    for (int i = 0; i < 8; i++) cornerMask.add(0);\n    for (int i = 0; i < 4; i++) {\n        edgeMask.get(edgePos.getVal()[i]).set(0, 0);\n        edgeMask.get(edgePos.getVal()[i]).set(1, (int) edgeOrientation.getVal()[i]);\n    }\n    for (int i = 4; i < 8; i++) {\n        edgeMask.get(edgePos.getVal()[i]).set(0, 1);\n        edgeMask.get(edgePos.getVal()[i]).set(1, (int) edgeOrientation.getVal()[i]);\n    }\n    for (int i = 8; i < 12; i++) {\n        edgeMask.get(edgePos.getVal()[i]).set(0, 0);\n        edgeMask.get(edgePos.getVal()[i]).set(1, (int) edgeOrientation.getVal()[i]);\n    }\n    for (int i = 0; i < 8; i++) cornerMask.set(cornerPos.getVal()[i], (int) cornerOrientation.getVal()[i]);\n    for (ArrayList<Integer> i : edgeMask) {\n        mask.add(i.get(0));\n        mask.add(i.get(1));\n    }\n    mask.addAll(cornerMask);\n    return mask;\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Masks/_3StageMask/Stage2.java ": 
{"imports":["com.cube.demo.rbxcb.rbxcb_3x3x3.Model.Cube","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks._4StageMask.Stage3","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks.StageMasker","java.util.ArrayList"],"classes":[{"name":"Stage2","annotations":[],"extendedClass":"","implementedInterfaces":["StageMasker"],"fields":[],"methods":[{"name":"mask","returnType":"ArrayList<Integer>","annotations":[],"parameters":["Cube c"],"body":"{\n    StageMasker sm = new Stage3();\n    return sm.mask(c);\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Masks/_3StageMask/Stage3.java ": 
{"imports":["com.cube.demo.rbxcb.rbxcb_3x3x3.Model.Cube","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks._4StageMask.Stage4","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks.StageMasker","java.util.ArrayList"],"classes":[{"name":"Stage3","annotations":[],"extendedClass":"","implementedInterfaces":["StageMasker"],"fields":[],"methods":[{"name":"mask","returnType":"ArrayList<Integer>","annotations":[],"parameters":["Cube c"],"body":"{\n    StageMasker sm = new Stage4();\n    return sm.mask(c);\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Masks/_4StageMask/Stage1.java ": 
{"imports":["com.cube.demo.rbxcb.rbxcb_3x3x3.Model.Cube","com.cube.demo.rbxcb.rbxcb_3x3x3.Model.EdgeOrientation","com.cube.demo.rbxcb.rbxcb_3x3x3.Model.EdgePos","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks.StageMasker","java.util.ArrayList"],"classes":[{"name":"Stage1","annotations":[],"extendedClass":"","implementedInterfaces":["StageMasker"],"fields":[],"methods":[{"name":"mask","returnType":"ArrayList<Integer>","annotations":[],"parameters":["Cube c"],"body":"{\n    ArrayList<Integer> mask = new ArrayList<>();\n    for (int i = 0; i < 12; i++) mask.add(0);\n    EdgePos edgePos = c.getEdge().getEdgePos();\n    EdgeOrientation edgeOrientation = c.getEdge().getEdgeOrientation();\n    for (int i = 0; i < 12; i++) {\n        int edgePiecePosition = edgePos.getVal()[i];\n        int edgePieceOrientation = edgeOrientation.getVal()[i];\n        if (edgePiecePosition < 4 || edgePiecePosition > 7) {\n            if (Math.abs(edgePieceOrientation) == 3)\n                mask.set(edgePiecePosition, 1);\n        } else {\n            if (Math.abs(edgePieceOrientation) == 2)\n                mask.set(edgePiecePosition, 1);\n        }\n    }\n    return mask;\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Masks/_4StageMask/Stage2.java ": 
{"imports":["com.cube.demo.rbxcb.rbxcb_3x3x3.Model.Cube","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks.StageMasker","java.util.ArrayList"],"classes":[{"name":"Stage2","annotations":[],"extendedClass":"","implementedInterfaces":["StageMasker"],"fields":[],"methods":[{"name":"mask","returnType":"ArrayList<Integer>","annotations":[],"parameters":["Cube c"],"body":"{\n    ArrayList<Integer> mask = new ArrayList<>();\n    ArrayList<Integer> cornerMask = new ArrayList<>();\n    ArrayList<Integer> edgeMask = new ArrayList<>();\n    for (int i = 0; i < 8; i++) cornerMask.add(0);\n    for (int i = 0; i < 12; i++) edgeMask.add(0);\n    for (int i = 0; i < 8; i++) {\n        int cornerPiecePosition = c.getCorner().getCornerPos().getVal()[i];\n        int cornerPieceOrientation = c.getCorner().getCornerOrientation().getVal()[i];\n        cornerMask.set(cornerPiecePosition, cornerPieceOrientation);\n    }\n    for (int i = 0; i < 12; i++) {\n        int edgePiecePosition = c.getEdge().getEdgePos().getVal()[i];\n        boolean positionGroup = edgePiecePosition < 4 || edgePiecePosition > 7;\n        boolean pieceGroup = i < 4 || i > 7;\n        edgeMask.set(edgePiecePosition, positionGroup != pieceGroup ? 1 : 0);\n    }\n    mask.addAll(cornerMask);\n    mask.addAll(edgeMask);\n    return mask;\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Masks/_4StageMask/Stage3.java ": 
{"imports":["com.cube.demo.rbxcb.rbxcb_3x3x3.Model.Cube","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks.StageMasker","java.util.ArrayList"],"classes":[{"name":"Stage3","annotations":[],"extendedClass":"","implementedInterfaces":["StageMasker"],"fields":[],"methods":[{"name":"mask","returnType":"ArrayList<Integer>","annotations":[],"parameters":["Cube c"],"body":"{\n    ArrayList<Integer> mask = new ArrayList<>();\n    ArrayList<Integer> parityEdges = new ArrayList<>();\n    ArrayList<Integer> parityCorners = new ArrayList<>();\n    ArrayList<Integer> parityCornerPos = new ArrayList<>();\n    for (int i = 0; i < 12; i++) parityEdges.add(0);\n    for (int i = 0; i < 8; i++) {\n        parityCorners.add(0);\n        parityCornerPos.add(0);\n    }\n    for (int i = 0; i < 12; i++) parityEdges.set(c.getEdge().getEdgePos().getVal()[i], Cube.edgePossiblePlacesStage3[c.getEdge().getEdgePos().getVal()[i]][i]);\n    for (int i = 0; i < 8; i++) {\n        parityCorners.set(c.getCorner().getCornerPos().getVal()[i], Cube.cornerPossiblePlacesStage3[c.getCorner().getCornerPos().getVal()[i]][i]);\n        parityCornerPos.set(c.getCorner().getCornerPos().getVal()[i], i / 4);\n    }\n    for (int i = 0; i < 4; i++) mask.add(parityEdges.get(i));\n    for (int i = 8; i < 12; i++) mask.add(parityEdges.get(i));\n    mask.addAll(parityCorners);\n    mask.addAll(parityCornerPos);\n    for (byte i : c.getCorner().getCornerPos().getVal()) mask.add((int) i);\n    return mask;\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Masks/_4StageMask/Stage4.java ": 
{"imports":["com.cube.demo.rbxcb.rbxcb_3x3x3.Model.Cube","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks.StageMasker","java.util.ArrayList"],"classes":[{"name":"Stage4","annotations":[],"extendedClass":"","implementedInterfaces":["StageMasker"],"fields":[],"methods":[{"name":"mask","returnType":"ArrayList<Integer>","annotations":[],"parameters":["Cube c"],"body":"{\n    ArrayList<Integer> mask = new ArrayList<>();\n    for (byte i : c.getEdge().getEdgePos().getVal()) mask.add((int) i);\n    for (byte i : c.getCorner().getCornerPos().getVal()) mask.add((int) i);\n    return mask;\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Model/Corner.java ": 
{"imports":[],"classes":[{"name":"Corner","annotations":[],"extendedClass":"","implementedInterfaces":["Cloneable"],"fields":[{"name":"cornerPos","type":"CornerPos","annotations":[]},{"name":"cornerOrientation","type":"CornerOrientation","annotations":[]}],"methods":[{"name":"clone","returnType":"Corner","annotations":["Override"],"parameters":[],"body":"{\n    return new Corner(this.cornerPos.clone(), this.getCornerOrientation().clone());\n}"},{"name":"toString","returnType":"String","annotations":["Override"],"parameters":[],"body":"{\n    return \"Corner{\\n\" + \"cornerPos=\" + cornerPos + \",\\ncornerOrientation=\" + cornerOrientation + \"\\n}\";\n}"},{"name":"getCornerPos","returnType":"CornerPos","annotations":[],"parameters":[],"body":"{\n    return cornerPos;\n}"},{"name":"getCornerOrientation","returnType":"CornerOrientation","annotations":[],"parameters":[],"body":"{\n    return cornerOrientation;\n}"},{"name":"setCornerOrientation","returnType":"void","annotations":[],"parameters":["CornerOrientation cornerOrientation"],"body":"{\n    this.cornerOrientation = cornerOrientation;\n}"},{"name":"setCornerPos","returnType":"void","annotations":[],"parameters":["CornerPos cornerPos"],"body":"{\n    this.cornerPos = cornerPos;\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Model/CornerOrientation.java ": 
{"imports":["java.util.Arrays"],"classes":[{"name":"CornerOrientation","annotations":[],"extendedClass":"","implementedInterfaces":["Cloneable"],"fields":[{"name":"val","type":"byte[]","annotations":[]},{"name":"SOLVED_VAL","type":"byte[]","annotations":[]}],"methods":[{"name":"clone","returnType":"CornerOrientation","annotations":["Override"],"parameters":[],"body":"{\n    return new CornerOrientation(this.val.clone());\n}"},{"name":"toString","returnType":"String","annotations":["Override"],"parameters":[],"body":"{\n    return \"CornerOrientation{\\n\" + \"val=\" + Arrays.toString(val) + \"\\n}\";\n}"},{"name":"getVal","returnType":"byte[]","annotations":[],"parameters":[],"body":"{\n    return val;\n}"},{"name":"setVal","returnType":"void","annotations":[],"parameters":["int i","byte val"],"body":"{\n    this.val[i] = val;\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Model/CornerPos.java ": 
{"imports":["java.util.Arrays"],"classes":[{"name":"CornerPos","annotations":[],"extendedClass":"","implementedInterfaces":["Cloneable"],"fields":[{"name":"val","type":"byte[]","annotations":[]},{"name":"SOLVED_VAL","type":"byte[]","annotations":[]}],"methods":[{"name":"clone","returnType":"CornerPos","annotations":["Override"],"parameters":[],"body":"{\n    return new CornerPos(this.val.clone());\n}"},{"name":"toString","returnType":"String","annotations":["Override"],"parameters":[],"body":"{\n    return \"CornerPos{\\n\" + \"val=\" + Arrays.toString(val) + \"\\n}\";\n}"},{"name":"getVal","returnType":"byte[]","annotations":[],"parameters":[],"body":"{\n    return val;\n}"},{"name":"setVal","returnType":"void","annotations":[],"parameters":["int i","byte val"],"body":"{\n    this.val[i] = val;\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Model/Cube.java ": 
{"imports":["java.util","java.util.concurrent","java.util.concurrent.atomic.AtomicReference"],"classes":[{"name":"Cube","annotations":[],"extendedClass":"","implementedInterfaces":["Cloneable"],"fields":[{"name":"nextEdgePos","type":"Map<Character, EdgePos>","annotations":[]},{"name":"nextCornerPos","type":"Map<Character, CornerPos>","annotations":[]},{"name":"nextEdgeOrientation","type":"Map<Character, List<Map<Byte, Byte>>>","annotations":[]},{"name":"nextCornerOrientation","type":"Map<Character, List<Map<Byte, Byte>>>","annotations":[]},{"name":"edgeList","type":"byte[][]","annotations":[]},{"name":"cornerList","type":"byte[][]","annotations":[]},{"name":"binEncoding","type":"Map<Character, Byte>","annotations":[]},{"name":"priority","type":"Map<Character, Byte>","annotations":[]},{"name":"edgeNumberForPos","type":"Map<Byte, Byte>","annotations":[]},{"name":"cornerNumberForPos","type":"Map<Byte, Byte>","annotations":[]},{"name":"edgePossiblePlacesStage3","type":"int[][]","annotations":[]},{"name":"cornerPossiblePlacesStage3","type":"int[][]","annotations":[]},{"name":"edge","type":"Edge","annotations":[]},{"name":"corner","type":"Corner","annotations":[]}],"methods":[{"name":"clone","returnType":"Cube","annotations":["Override"],"parameters":[],"body":"{\n    return new Cube(this.getEdge().clone(), this.getCorner().clone());\n}"},{"name":"execute","returnType":"Cube","annotations":[],"parameters":["Cube c","String s"],"body":"{\n    Cube temp = c.clone();\n    String[] moves = s.split(\" \");\n    if (moves.length > 1) {\n        StringBuilder sBuilder = new StringBuilder();\n        for (String string : moves) {\n            if (string.length() == 1)\n                sBuilder.append(string.charAt(0));\n            else if (string.charAt(1) == '2')\n                sBuilder.append(String.valueOf(string.charAt(0)).repeat(2));\n            else\n                sBuilder.append(String.valueOf(string.charAt(0)).repeat(3));\n        }\n        s = sBuilder.toString();\n    }\n    for (int i = 0; i < s.length(); i++) {\n        char ch = s.charAt(i);\n        EdgePos edgePos = temp.getEdge().getEdgePos().clone();\n        EdgeOrientation edgeOrientation = temp.getEdge().getEdgeOrientation().clone();\n        for (int j = 0; j < 12; j++) {\n            edgeOrientation.setVal(j, nextEdgeOrientation.get(ch).get(edgePos.getVal()[j]).get(edgeOrientation.getVal()[j]));\n            edgePos.setVal(j, nextEdgePos.get(ch).getVal()[edgePos.getVal()[j]]);\n        }\n        temp.setEdge(new Edge(edgePos, edgeOrientation));\n        CornerPos cornerPos = temp.getCorner().getCornerPos().clone();\n        CornerOrientation cornerOrientation = temp.getCorner().getCornerOrientation().clone();\n        for (int j = 0; j < 8; j++) {\n            cornerOrientation.setVal(j, nextCornerOrientation.get(ch).get(cornerPos.getVal()[j]).get(cornerOrientation.getVal()[j]));\n            cornerPos.setVal(j, nextCornerPos.get(ch).getVal()[cornerPos.getVal()[j]]);\n        }\n        temp.setCorner(new Corner(cornerPos, cornerOrientation));\n    }\n    return temp;\n}"},{"name":"reverseAlgorithm","returnType":"String","annotations":[],"parameters":["String s"],"body":"{\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) result.append(String.valueOf(s.charAt(i)).repeat(3));\n    return new StringBuilder(result.toString()).reverse().toString();\n}"},{"name":"getAlgorithm","returnType":"ArrayList<String>","annotations":[],"parameters":["String moves"],"body":"{\n    class Temp {\n\n        final char ch;\n\n        final byte b;\n\n        public Temp(char ch, byte b) {\n            this.ch = ch;\n            this.b = b;\n        }\n    }\n    Stack<Temp> s = new Stack<>();\n    ArrayList<String> v = new ArrayList<>(Arrays.asList(\"\", \"\", \"2\", \"'\"));\n    ArrayList<String> result = new ArrayList<>();\n    for (int i = 0; i < moves.length(); i++) {\n        if (s.isEmpty() || s.peek().ch != moves.charAt(i))\n            s.push(new Temp(moves.charAt(i), (byte) 1));\n        else {\n            Temp x = s.pop();\n            if (x.b != (byte) 3)\n                s.push(new Temp(x.ch, (byte) (x.b + 1)));\n        }\n    }\n    while (!s.isEmpty()) {\n        Temp x = s.pop();\n        if (x.b != 0)\n            result.add(0, x.ch + v.get(x.b));\n    }\n    return result;\n}\n[Local class: Temp]"},{"name":"toString","returnType":"String","annotations":["Override"],"parameters":[],"body":"{\n    return \"Cube{\\n\" + \"edge=\" + edge.toString() + \",\\ncorner=\" + corner.toString() + \"\\n}\";\n}"},{"name":"getEdge","returnType":"Edge","annotations":[],"parameters":[],"body":"{\n    return edge;\n}"},{"name":"setEdge","returnType":"void","annotations":[],"parameters":["Edge edge"],"body":"{\n    this.edge = edge;\n}"},{"name":"getCorner","returnType":"Corner","annotations":[],"parameters":[],"body":"{\n    return corner;\n}"},{"name":"setCorner","returnType":"void","annotations":[],"parameters":["Corner corner"],"body":"{\n    this.corner = corner;\n}"}],"nestedClasses":[{"name":"Temp","annotations":[],"extendedClass":"","implementedInterfaces":[],"fields":[{"name":"ch","type":"char","annotations":[]},{"name":"b","type":"byte","annotations":[]}],"methods":[],"nestedClasses":[]}]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Model/Edge.java ": 
{"imports":[],"classes":[{"name":"Edge","annotations":[],"extendedClass":"","implementedInterfaces":["Cloneable"],"fields":[{"name":"edgePos","type":"EdgePos","annotations":[]},{"name":"edgeOrientation","type":"EdgeOrientation","annotations":[]}],"methods":[{"name":"clone","returnType":"Edge","annotations":["Override"],"parameters":[],"body":"{\n    return new Edge(this.getEdgePos().clone(), this.getEdgeOrientation().clone());\n}"},{"name":"toString","returnType":"String","annotations":["Override"],"parameters":[],"body":"{\n    return \"Edge{\\n\" + \"edgePos=\" + edgePos.toString() + \",\\nedgeOrientation=\" + edgeOrientation.toString() + \"\\n}\";\n}"},{"name":"getEdgePos","returnType":"EdgePos","annotations":[],"parameters":[],"body":"{\n    return edgePos;\n}"},{"name":"getEdgeOrientation","returnType":"EdgeOrientation","annotations":[],"parameters":[],"body":"{\n    return edgeOrientation;\n}"},{"name":"setEdgeOrientation","returnType":"void","annotations":[],"parameters":["EdgeOrientation edgeOrientation"],"body":"{\n    this.edgeOrientation = edgeOrientation;\n}"},{"name":"setEdgePos","returnType":"void","annotations":[],"parameters":["EdgePos edgePos"],"body":"{\n    this.edgePos = edgePos;\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Model/EdgeOrientation.java ": 
{"imports":["java.util.Arrays"],"classes":[{"name":"EdgeOrientation","annotations":[],"extendedClass":"","implementedInterfaces":["Cloneable"],"fields":[{"name":"val","type":"byte[]","annotations":[]},{"name":"SOLVED_VAL","type":"byte[]","annotations":[]}],"methods":[{"name":"clone","returnType":"EdgeOrientation","annotations":["Override"],"parameters":[],"body":"{\n    return new EdgeOrientation(this.val.clone());\n}"},{"name":"toString","returnType":"String","annotations":["Override"],"parameters":[],"body":"{\n    return \"EdgeOrientation{\\n\" + \"val=\" + Arrays.toString(val) + \"\\n}\";\n}"},{"name":"getVal","returnType":"byte[]","annotations":[],"parameters":[],"body":"{\n    return val;\n}"},{"name":"setVal","returnType":"void","annotations":[],"parameters":["int i","byte val"],"body":"{\n    this.val[i] = val;\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Model/EdgePos.java ": 
{"imports":["java.util.Arrays"],"classes":[{"name":"EdgePos","annotations":[],"extendedClass":"","implementedInterfaces":["Cloneable"],"fields":[{"name":"val","type":"byte[]","annotations":[]},{"name":"SOLVED_VAL","type":"byte[]","annotations":[]}],"methods":[{"name":"clone","returnType":"EdgePos","annotations":["Override"],"parameters":[],"body":"{\n    return new EdgePos(this.val.clone());\n}"},{"name":"toString","returnType":"String","annotations":["Override"],"parameters":[],"body":"{\n    return \"EdgePos{\\n\" + \"val=\" + Arrays.toString(val) + \"\\n}\";\n}"},{"name":"getVal","returnType":"byte[]","annotations":[],"parameters":[],"body":"{\n    return val;\n}"},{"name":"setVal","returnType":"void","annotations":[],"parameters":["int i","byte val"],"body":"{\n    this.val[i] = val;\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Solvers/OLL_Solver.java ": 
{"imports":["com.cube.demo.rbxcb.rbxcb_3x3x3.Masks.CFOP_Mask.OLL_Mask","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks.StageMasker","com.cube.demo.rbxcb.rbxcb_3x3x3.Model.Cube","java.util.ArrayList"],"classes":[{"name":"OLL_Solver","annotations":[],"extendedClass":"Solver","implementedInterfaces":[],"fields":[{"name":"masks","type":"StageMasker[]","annotations":[]},{"name":"moveRestrictions","type":"String[][]","annotations":[]}],"methods":[{"name":"solve","returnType":"ArrayList<String>","annotations":[],"parameters":["Cube c"],"body":"{\n    return super.solve(c, OLL_Solver.masks, OLL_Solver.moveRestrictions);\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Solvers/Solver.java ": 
{"imports":["com.cube.demo.rbxcb.rbxcb_3x3x3.Model.Cube","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks.StageMasker","com.cube.demo.rbxcb.rbxcb_3x3x3.StageSolver","java.util.ArrayList"],"classes":[{"name":"Solver","annotations":[],"extendedClass":"","implementedInterfaces":[],"fields":[],"methods":[{"name":"solve","returnType":"ArrayList<String>","annotations":[],"parameters":["Cube c","StageMasker[] masks","String[][] moveRestrictions"],"body":"{\n    StringBuilder solution = new StringBuilder();\n    int n = masks.length;\n    for (int i = 0; i < n; i++) {\n        String sol = StageSolver.solve(c, moveRestrictions[i], masks[i]);\n        c = Cube.execute(c, sol);\n        solution.append(sol);\n    }\n    return Cube.getAlgorithm(solution.toString());\n}"},{"name":"solve","returnType":"ArrayList<String>","annotations":[],"parameters":["Cube c"],"body":""}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Solvers/_2StageSolver.java ": 
{"imports":["com.cube.demo.rbxcb.rbxcb_3x3x3.Model.Cube","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks.StageMasker","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks._2StageMask","java.util.ArrayList"],"classes":[{"name":"_2StageSolver","annotations":[],"extendedClass":"Solver","implementedInterfaces":[],"fields":[{"name":"masks","type":"StageMasker[]","annotations":[]},{"name":"moveRestrictions","type":"String[][]","annotations":[]}],"methods":[{"name":"solve","returnType":"ArrayList<String>","annotations":[],"parameters":["Cube c"],"body":"{\n    return super.solve(c, _2StageSolver.masks, _2StageSolver.moveRestrictions);\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Solvers/_3StageSolver.java ": 
{"imports":["com.cube.demo.rbxcb.rbxcb_3x3x3.Model.Cube","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks.StageMasker","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks._3StageMask","java.util.ArrayList"],"classes":[{"name":"_3StageSolver","annotations":[],"extendedClass":"Solver","implementedInterfaces":[],"fields":[{"name":"masks","type":"StageMasker[]","annotations":[]},{"name":"moveRestrictions","type":"String[][]","annotations":[]}],"methods":[{"name":"solve","returnType":"ArrayList<String>","annotations":[],"parameters":["Cube c"],"body":"{\n    return super.solve(c, _3StageSolver.masks, _3StageSolver.moveRestrictions);\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/cube/demo/rbxcb/rbxcb_3x3x3/Solvers/_4StageSolver.java ": 
{"imports":["com.cube.demo.rbxcb.rbxcb_3x3x3.Model.Cube","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks.StageMasker","com.cube.demo.rbxcb.rbxcb_3x3x3.Masks._4StageMask","java.util.ArrayList"],"classes":[{"name":"_4StageSolver","annotations":[],"extendedClass":"Solver","implementedInterfaces":[],"fields":[{"name":"masks","type":"StageMasker[]","annotations":[]},{"name":"moveRestrictions","type":"String[][]","annotations":[]}],"methods":[{"name":"solve","returnType":"ArrayList<String>","annotations":[],"parameters":["Cube c"],"body":"{\n    return super.solve(c, _4StageSolver.masks, _4StageSolver.moveRestrictions);\n}"}],"nestedClasses":[]}]}  , "demo/src/test/java/com/cube/demo/DemoApplicationTests.java ": 
{"imports":["org.junit.jupiter.api.Test","org.springframework.boot.test.context.SpringBootTest"],"classes":[{"name":"DemoApplicationTests","annotations":["SpringBootTest"],"extendedClass":"","implementedInterfaces":[],"fields":[],"methods":[{"name":"contextLoads","returnType":"void","annotations":["Test"],"parameters":[],"body":"{\n}"}],"nestedClasses":[]}]}} 
